{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/clsx@2.0.0/node_modules/clsx/dist/clsx.mjs", "../../../../../node_modules/.pnpm/cva@1.0.0-beta.1_typescript@5.3.3/node_modules/cva/src/index.ts"],
  "sourcesContent": ["function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;", "import { clsx } from \"clsx\";\n\n/* Types\n  ============================================ */\n\n/* clsx\n  ---------------------------------- */\n\n// When compiling with `declaration: true`, many projects experience the dreaded\n// TS2742 error. To combat this, we copy clsx's types manually.\n// Should this project move to JSDoc, this workaround would no longer be needed.\n\ntype ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\ntype ClassDictionary = Record<string, any>;\ntype ClassArray = ClassValue[];\n\n/* Utils\n  ---------------------------------- */\n\ntype OmitUndefined<T> = T extends undefined ? never : T;\ntype StringToBoolean<T> = T extends \"true\" | \"false\" ? boolean : T;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\nexport type VariantProps<Component extends (...args: any) => any> = Omit<\n  OmitUndefined<Parameters<Component>[0]>,\n  \"class\" | \"className\"\n>;\n\n/* compose\n  ---------------------------------- */\n\nexport interface Compose {\n  <T extends ReturnType<CVA>[]>(...components: [...T]): (\n    props?: (\n      | UnionToIntersection<\n          {\n            [K in keyof T]: VariantProps<T[K]>;\n          }[number]\n        >\n      | undefined\n    ) &\n      CVAClassProp\n  ) => string;\n}\n\n/* cx\n  ---------------------------------- */\n\nexport interface CX {\n  (...inputs: ClassValue[]): string;\n}\n\nexport type CXOptions = Parameters<CX>;\nexport type CXReturn = ReturnType<CX>;\n\n/* cva\n  ============================================ */\n\ntype CVAConfigBase = { base?: ClassValue };\ntype CVAVariantShape = Record<string, Record<string, ClassValue>>;\ntype CVAVariantSchema<V extends CVAVariantShape> = {\n  [Variant in keyof V]?: StringToBoolean<keyof V[Variant]> | undefined;\n};\ntype CVAClassProp =\n  | {\n      class?: ClassValue;\n      className?: never;\n    }\n  | {\n      class?: never;\n      className?: ClassValue;\n    };\n\nexport interface CVA {\n  <\n    _ extends \"cva's generic parameters are restricted to internal use only.\",\n    V\n  >(\n    config: V extends CVAVariantShape\n      ? CVAConfigBase & {\n          variants?: V;\n          compoundVariants?: (V extends CVAVariantShape\n            ? (\n                | CVAVariantSchema<V>\n                | {\n                    [Variant in keyof V]?:\n                      | StringToBoolean<keyof V[Variant]>\n                      | StringToBoolean<keyof V[Variant]>[]\n                      | undefined;\n                  }\n              ) &\n                CVAClassProp\n            : CVAClassProp)[];\n          defaultVariants?: CVAVariantSchema<V>;\n        }\n      : CVAConfigBase & {\n          variants?: never;\n          compoundVariants?: never;\n          defaultVariants?: never;\n        }\n  ): (\n    props?: V extends CVAVariantShape\n      ? CVAVariantSchema<V> & CVAClassProp\n      : CVAClassProp\n  ) => string;\n}\n\n/* defineConfig\n  ---------------------------------- */\n\nexport interface DefineConfigOptions {\n  hooks?: {\n    /**\n     * @deprecatedÂ please use `onComplete`\n     */\n    \"cx:done\"?: (className: string) => string;\n    /**\n     * Returns the completed string of concatenated classes/classNames.\n     */\n    onComplete?: (className: string) => string;\n  };\n}\n\nexport interface DefineConfig {\n  (options?: DefineConfigOptions): {\n    compose: Compose;\n    cx: CX;\n    cva: CVA;\n  };\n}\n\n/* Exports\n  ============================================ */\n\nconst falsyToString = <T extends unknown>(value: T) =>\n  typeof value === \"boolean\" ? `${value}` : value === 0 ? \"0\" : value;\n\nexport const defineConfig: DefineConfig = (options) => {\n  const cx: CX = (...inputs) => {\n    if (typeof options?.hooks?.[\"cx:done\"] !== \"undefined\")\n      return options?.hooks[\"cx:done\"](clsx(inputs));\n\n    if (typeof options?.hooks?.onComplete !== \"undefined\")\n      return options?.hooks.onComplete(clsx(inputs));\n\n    return clsx(inputs);\n  };\n\n  const cva: CVA = (config) => (props) => {\n    if (config?.variants == null)\n      return cx(config?.base, props?.class, props?.className);\n\n    const { variants, defaultVariants } = config;\n\n    const getVariantClassNames = Object.keys(variants).map(\n      (variant: keyof typeof variants) => {\n        const variantProp = props?.[variant as keyof typeof props];\n        const defaultVariantProp = defaultVariants?.[variant];\n\n        const variantKey = (falsyToString(variantProp) ||\n          falsyToString(\n            defaultVariantProp\n          )) as keyof typeof variants[typeof variant];\n\n        return variants[variant][variantKey];\n      }\n    );\n\n    const defaultsAndProps = {\n      ...defaultVariants,\n      // remove `undefined` props\n      ...(props &&\n        Object.entries(props).reduce<typeof props>(\n          (acc, [key, value]) =>\n            typeof value === \"undefined\" ? acc : { ...acc, [key]: value },\n          {} as typeof props\n        )),\n    };\n\n    const getCompoundVariantClassNames = config?.compoundVariants?.reduce(\n      (acc, { class: cvClass, className: cvClassName, ...cvConfig }) =>\n        Object.entries(cvConfig).every(([cvKey, cvSelector]) => {\n          const selector =\n            defaultsAndProps[cvKey as keyof typeof defaultsAndProps];\n\n          return Array.isArray(cvSelector)\n            ? cvSelector.includes(selector)\n            : selector === cvSelector;\n        })\n          ? [...acc, cvClass, cvClassName]\n          : acc,\n      [] as ClassValue[]\n    );\n\n    return cx(\n      config?.base,\n      getVariantClassNames,\n      getCompoundVariantClassNames,\n      props?.class,\n      props?.className\n    );\n  };\n\n  const compose: Compose =\n    (...components) =>\n    (props) => {\n      const propsWithoutClass = Object.fromEntries(\n        Object.entries(props || {}).filter(\n          ([key]) => ![\"class\", \"className\"].includes(key)\n        )\n      );\n\n      return cx(\n        components.map((component) => component(propsWithoutClass)),\n        props?.class,\n        props?.className\n      );\n    };\n\n  return {\n    compose,\n    cva,\n    cx,\n  };\n};\n\nexport const { compose, cva, cx } = defineConfig();\n"],
  "mappings": "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",
  "names": []
}
