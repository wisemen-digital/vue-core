import { join, parse, resolve } from 'path'
import { components } from './components'
import { ComponentMeta, createChecker  } from 'vue-component-meta'
import { fileURLToPath } from 'node:url'
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs'
import MarkdownIt from 'markdown-it'

interface Component {
  sourceFolder: string
  targetFolder: string
  componentName: string
}

interface ParsedMeta {
  props: any[]
  events: any[]
  slots: any[]
  interfaces?: InterfaceMeta[]
}

interface InterfaceMeta {
  name: string
  content: string
}

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const md = new MarkdownIt()

const tsconfigChecker = createChecker(
  resolve(__dirname, '../../packages/components/tsconfig.app.json'),
  {
    forceUseTs: true,
    printer: { newLine: 1 },
  },
)

function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
}

function toCamelCase(str: string): string {
  return str.replace(/^([A-Z])/, (match) => match.toLowerCase());
}

function parseMeta(meta: ComponentMeta, styleInterfaces: InterfaceMeta[] = []): ParsedMeta {
  const props = meta.props
    .filter((prop: any) => !prop.global)
    .map((prop: any) => {
      let defaultValue = prop.default
      let type = prop.type
      const { name, description, required } = prop
      
      if (defaultValue === 'undefined')
        defaultValue = undefined

      return ({
        name,
        description: description,
        type: type.replace(/\s*\|\s*undefined/g, '').replace('unknown', 'T'),
        required,
        default: defaultValue ?? undefined,
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  const events = meta.events
    .map((event: any) => {
      const { name } = event
      const type = event.type.replace(/\s*\|\s*undefined/g, '').replace('unknown', 'T').replace(/\</g, '\\<').replace(/\>/g, '\\>')
      return ({
        name,
        description: md.render((event.description ?? '').replace(/^[ \t]+/gm, '')),
        type: type
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  const slots = meta.slots
    .map((slot: any) => {
      const { name, type, description } = slot

      const descriptionString = description ?? ''

      return ({
        name,
        description: descriptionString.replace(/^[ \t]+/gm, ''),
        type: type === 'any' ? '-' : type.replace(/\s*\|\s*undefined/g, '').replace('unknown', 'T'),
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  return {
    props,
    events,
    slots,
    interfaces: styleInterfaces,
  }
}

function extractInterfacesFromFile(filePath: string): InterfaceMeta[] {
  if (!existsSync(filePath)) return []

  const content = readFileSync(filePath, 'utf8')

  const interfaceRegex = /export\s+interface\s+([A-Za-z0-9_]+)(\s+extends\s+[A-Za-z0-9_]+)?\s*{([^}]*)}/gs
  const interfaces: InterfaceMeta[] = []

  let match: RegExpExecArray | null
  while ((match = interfaceRegex.exec(content)) !== null) {
    const interfaceName = match[1]
    const extendsClause = match[2] ? match[2].trim() : ''
    const body = match[3].trim()

    interfaces.push({
      name: interfaceName,
      content: `\`\`\`ts\nexport interface ${interfaceName} ${extendsClause} {\n${body}\n}\n\`\`\``,
    })
  }

  return interfaces
}

function generateMeta(meta: ParsedMeta): string {
  let parsedString = `<!-- This file is automatically generated, do not edit manually. -->\n`

  if (meta.props.length > 0) {
    parsedString += '\n## Props\n\n'
    parsedString += '| Prop | Type | Description | Default |\n'
    parsedString += '| ---- | ---- | ----------- | ------- |\n'

    // Sort props by required first, then alphabetically
    meta.props.sort((a, b) => {
      if (a.required && !b.required) {
        return -1
      }

      if (!a.required && b.required) {
        return 1
      }

      return a.name.localeCompare(b.name)
    })

    meta.props.forEach((prop: { 
      name: string; 
      type: string; 
      description: string; 
      required: boolean;
      default?: string;
    }) => {
      // const name = `${prop.name}${prop.required ? '*' : ''}`
      const name = prop.required ? `**${prop.name}***` : prop.name
      const type = `\`${prop.type.replace(/\|/g, '\\|')}\``
      const defaultValue = prop.default === undefined ? '' : `\`${prop.default}\``
      parsedString += `| ${name} | ${type} | ${prop.description} | ${defaultValue} |\n`
    })

    parsedString += '\n'
  }

  if (meta.slots.length > 0) {
    parsedString += '\n## Slots\n\n'
    parsedString += '| Slot | Slot Props | Description |\n'
    parsedString += '| --------- | ---- | ----------- |\n'
    meta.slots.forEach((slot: {
      name: string;
      type: string;
      description: string;
    }) => {
      const name = slot.name
      const type = `\`${slot.type.replace(/\|/g, '\\|')}\``
      const description = slot.description

      parsedString += `| ${name} | ${type} | ${description} |\n`
    })
    
    parsedString += '\n'
  }

  if (meta.events.length > 0) {
    parsedString += '\n## Events\n\n'
    parsedString += '| Event name | Type | Description |\n'
    parsedString += '| ---------- | ---- | ----------- |\n'
    meta.events.forEach((event: { name: string; type: string; description: string }) => {
      parsedString += `| \`${event.name}\` | ${event.type.replace(/\|/g, '\\|')} | ${event.description} |\n`
    })

    parsedString += '\n'
  }

  if (meta.interfaces?.length) {
    parsedString += '\n## Style configuration\n\n'
    parsedString += 'The following interfaces are defined in the componentâ€™s style configuration file:\n\n'
    meta.interfaces.forEach((item) => {
      parsedString += `#### ${item.name}\n\n${item.content}\n\n`
    })
  }

  return parsedString
}

function generateEmptyDocWithMeta(component: Component): void {
  const componentNameKebabCase = toKebabCase(component.componentName)

  const targetDirPath = resolve(__dirname, `../components/${component.targetFolder}`)

  if (!existsSync(targetDirPath))
    mkdirSync(targetDirPath)

  const componentMdFilePath = join(targetDirPath, `${componentNameKebabCase}.md`)

  // Check if md file already exists
  if (existsSync(componentMdFilePath)) {
    return
  }

  const template = `---
sidebar: auto
---

# ${componentNameKebabCase.split('-').map(word => word[0].toUpperCase() + word.slice(1)).join(' ')}

<!-- @include: ./${componentNameKebabCase}-meta.md -->
`

  writeFileSync(componentMdFilePath, template, 'utf8')
}

function formatCodeString(code: string): string {
  let indentLevel = 0

  return code
    // Add line breaks after semicolons and curly braces
    .replace(/;/g, ';\n')
    .replace(/{/g, '{\n')
    .replace(/}/g, '\n}')
    // Add indentation for nested structures
    .split('\n')
    .reduce((formatted, line) => {
      if (line.includes('}')) indentLevel--;
      formatted += '  '.repeat(indentLevel) + line.trim() + '\n';
      if (line.includes('{')) indentLevel++;
      return formatted;
    }, '')
    .trim();
}

function generateDocs(components: Component[]): void {
  components.forEach((component) => {
    console.group('Generating docs for', component.componentName)
    const sourcePath = resolve(__dirname, `../../packages/components/src/components/${component.sourceFolder}`)
    console.log('Component source path:', sourcePath)
    const componentMeta = tsconfigChecker.getComponentMeta(sourcePath)

    console.log(componentMeta.slots[0]?.type)

    const componentNameKebabCase = toKebabCase(component.componentName)
    const componentNameCamelCase = toCamelCase(component.componentName)
    const componentPath = component.sourceFolder.slice(0, component.sourceFolder.lastIndexOf("/"))

    const styleConfigFilePath = resolve(__dirname, `../../packages/components/src/components/${componentPath}/${componentNameCamelCase}Style.config.ts`)
    console.log('Checking for style config:', styleConfigFilePath)
    const styleInterfaces = extractInterfacesFromFile(styleConfigFilePath)

    const targetDirPath = resolve(__dirname, `../components/${component.targetFolder}`)
    console.log('Component target path:', targetDirPath)

    if (!existsSync(targetDirPath)) {
      console.log('Creating target directory:', targetDirPath)
      mkdirSync(targetDirPath)
    } else {
      console.log('Target directory already exists:', targetDirPath)
    }

    const metaMdFilePath = join(targetDirPath, `${componentNameKebabCase}-meta.md`)

    console.log('Meta file path:', metaMdFilePath)

    const parsedMeta = generateMeta(parseMeta(componentMeta, styleInterfaces))

    writeFileSync(metaMdFilePath, parsedMeta, 'utf8')

    console.groupEnd()
  })
}

generateDocs(components)