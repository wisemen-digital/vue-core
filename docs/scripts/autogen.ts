import { join, parse, resolve } from 'path'
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs'
import fg from 'fast-glob'
import MarkdownIt from 'markdown-it'
import { createChecker  } from 'vue-component-meta'
import { fileURLToPath } from 'node:url'
import { components } from '../../packages/constant/components'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const md = new MarkdownIt()

const checkerOptions = {
  forceUseTs: true,
  printer: { newLine: 1 },
}

const tsconfigChecker = createChecker(
  resolve(__dirname, '../../packages/components/tsconfig.app.json'),
  checkerOptions,
)

const allComponents = fg.sync(['src/components/**/*.vue'], {
  cwd: resolve(__dirname, '../../packages/components'),
  absolute: true,
  // Deep should be defaulted to infinity, but then it doesn't read nested folders. Specifying a number fixes it
  deep: 10,
});

const listOfComponents = Object.values(components).flatMap(i => i)
const primitiveComponents = allComponents.filter(i => listOfComponents.includes(parse(i).name))

function parseMeta(meta: any) {
  const props = meta.props
    .filter((prop: any) => !prop.global)
    .map((prop: any) => {
      let defaultValue = prop.default
      let type = prop.type
      const { name, description, required } = prop
      
      if (defaultValue === 'undefined')
        defaultValue = undefined

      return ({
        name,
        description: description,
        type: type.replace(/\s*\|\s*undefined/g, ''),
        required,
        default: defaultValue ?? undefined,
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  const events = meta.events
    .map((event: any) => {
      const { name, type } = event
      return ({
        name,
        description: md.render((event.description ?? '').replace(/^[ \t]+/gm, '')),
        type: type.replace(/\s*\|\s*undefined/g, ''),
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  const slots = meta.slots
    .map((slot: any) => {
      const { name, type, description } = slot
      const descriptionString = description ?? ''
      return ({
        name,
        description: descriptionString.replace(/^[ \t]+/gm, ''),
        type: type === "{}" ? "None" : type.replace(/\s*\|\s*undefined/g, ''),
      })
    })
    .sort((a: { name: string }, b: { name: string }) => a.name.localeCompare(b.name))

  return {
    props,
    events,
    slots,
  }
}

function generateDocsForComponents() {
  primitiveComponents.forEach((componentPath) => {
    const componentName = parse(componentPath).name
    const meta = parseMeta(tsconfigChecker.getComponentMeta(componentPath))

    const componentFolderName = parse(componentPath).dir.match(/src\/components\/([^\/]+)/)?.[1]

    const metaDirPath = resolve(__dirname, `../components/${componentFolderName}`)

    // If directory doesn't exist, create
    if (!existsSync(metaDirPath))
      mkdirSync(metaDirPath)

    const componentNameKebabCase = componentName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
    const metaMdFilePath = join(metaDirPath, `${componentNameKebabCase}-meta.md`)

    const componentPlaygroundName = `${componentName}Playground`
    
    // Add: auto-generated comment
    let parsedString = `<!-- This file is automatically generated, do not edit manually. -->\n\n`

    // Create string: playground file & title
    parsedString += `<script setup>\nimport ${componentPlaygroundName} from './${componentPlaygroundName}.vue'\n</script>\n\n<${componentPlaygroundName} />\n`

    // Create: tables for props & models, slots, events
    if (meta.props.length) {
      parsedString += '\n## Props\n\n'
      parsedString += '| Prop | Type | Description | Default |\n'
      parsedString += '| ---- | ---- | ----------- | ------- |\n'
      meta.props.forEach((prop: { 
        name: string; 
        type: string; 
        description: string; 
        required: boolean;
        default?: string;
      }) => {
        const name = `${prop.name}${prop.required ? '*' : ''}`
        const type = `\`${prop.type.replace(/\|/g, '\\|')}\``
        const defaultValue = prop.default === undefined ? '' : `\`${prop.default}\``
        parsedString += `| ${name} | ${type} | ${prop.description} | ${defaultValue} |\n`
      })
      parsedString += '\n'
    }

    if (meta.slots.length) {
      parsedString += '\n## Slots\n\n'
      parsedString += '| Slot | Type | Description |\n'
      parsedString += '| --------- | ---- | ----------- |\n'
      meta.slots.forEach((slot: {
        name: string;
        type: string;
        description: string;
      }) => {
        parsedString += `| \`${slot.name}\` | ${slot.type.replace(/\{/g, '\\{').replace(/\}/g, '\\}')} | ${slot.description} |\n`
      })
      parsedString += '\n'
    }

    if (meta.events.length) {
      parsedString += '\n## Events\n\n'
      parsedString += '| Event name | Type | Description |\n'
      parsedString += '| ---------- | ---- | ----------- |\n'
      meta.events.forEach((event: { name: string; type: string; description: string }) => {
        parsedString += `| \`${event.name}\` | ${event.type.replace(/\|/g, '\\|')} | ${event.description} |\n`
      })
      parsedString += '\n'
    }

      writeFileSync(metaMdFilePath, parsedString, 'utf8');
  })
}

generateDocsForComponents()
